---
marp: true
---

# DB 구조화 아이디어

---

# 1차 피드백

* 각 테이블에 버전 데이터가 있으면 좋겠다.
    + 버전 정보 테이블을 만들어 각 테이블의 버전 현황 컬럼을 FK로 실제 테이블과 연결, 테이블 갱신시 버전 정보 테이블도 갱신하여 버전에 대한 정보를 표시
* 메인 피쳐인 개인 스탯에 대한 테이블을 추가
    + 개인 스탯 테이블의 추가를 위해서는 실제 매치 데이터가 필요하므로 샘플 데이터로 매치 데이터의 1차 가공 형태 테이블 구성이 먼저.

---

## < 전적 검색 이론 1: 데이터 누적과 매치 ID 비교 >

### 전제: 매치 ID가 매 새로운 매치마다 점점 오르는 수라고 가정한다. 또한, 준비한 API KEY들이 일 단위로 발생하는 모든 한국 서버의 게임 수를 처리 할 수 있는 능력을 가진다고 가정한다.

먼저 항시 전적 누적을 위한 다수의 API KEY와 유저의 전적 갱신 요청에 대응 할 소수의 유휴 상태 API KEY를 준비한다.

전적 데이터 누적은 티어별로 테이블을 나누어 진행하며 각 테이블의 처리량 부하도를 측정하여 API KEY를 티어별로 알맞게 배분하고 또한 각 티어별 테이블의 가장 최신의(가장 높은 수의) 매치 ID를 검색하는 확인용 메소드를 만든다.

유저의 전적 갱신 요청이 들어오면 유저의 티어에 해당하는 최신 매치 ID를 가져온 후 유휴 상태인 API KEY를 사용하여 해당 유저의 최근 게임을 불러오기 시작한다.
유저의 게임을 불러오는 도중 가져온 티어 테이블의 최신 매치 ID보다 작은 수의 게임을 가져왔다면 최근 게임 불러오기를 멈추고 해당 티어의 테이블에서 유저의 전적을 쿼리하여 가져와 이를 페이지에 표시한다.

---

## 이론 1의 한계점:

1. 매일 누적되는 게임 수를 따라잡지 못한다면 점점 갱신이 늦어져 결국 전적 갱신으로 가져오는 게임의 일자가 늦춰지는 힘 싸움의 한계를 가지고 있다.

2. 유저의 티어가 자주 변동하는 경우 다수의 테이블에서 쿼리를 해야하여 쿼리가 다소 복잡하고 느려질 수 있다.

3. 게임 수를 따라잡을 API KEY의 물량이 준비된다 한들, 학원 컴퓨터의 성능이 이를 따라가지 못할 가능성이 높기 때문에 당장은 실현 가능성이 낮다.

4. 누적 시키는 게임에 빈틈이 생긴다면 이를 감지하기도 어려울 뿐더러 이런 데이터 손실이 유저의 전적을 정확하게 표시하지 못하는 무결성 문제로 직결되기 매우 쉽다.